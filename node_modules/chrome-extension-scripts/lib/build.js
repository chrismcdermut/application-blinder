'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _child_process = require('child_process');

var _fsExtra = require('fs-extra');

var _fsExtra2 = _interopRequireDefault(_fsExtra);

var _safe = require('colors/safe');

var _safe2 = _interopRequireDefault(_safe);

var _webpack = require('webpack');

var _webpack2 = _interopRequireDefault(_webpack);

var _easyRequire = require('./utils/easyRequire');

var _easyRequire2 = _interopRequireDefault(_easyRequire);

var _override = require('./webpack/override');

var _override2 = _interopRequireDefault(_override);

var _log = require('./utils/log');

var log = _interopRequireWildcard(_log);

var _shared = require('./shared');

var _webpackConfig = require('./webpack/webpack.config.prod');

var _webpackConfig2 = _interopRequireDefault(_webpackConfig);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

process.env.NODE_ENV = 'production';

// Native


// npm


// our


/**
 * Clear reelase directory
 *
 * @param  {String} path Release directory path
 * @return {Promise}
 */
function prepareReleaseDir(options) {
  return new Promise(function (resolve, reject) {
    _fsExtra2.default.remove(options.release, function () {
      _fsExtra2.default.mkdirs(options.release, function () {
        resolve();
      });
    });
  });
}

/**
 * Build production release
 *
 * @param  {Object} webpackConfig
 * @return {Promise}
 */
function webpackProduction(webpackConfig) {
  return new Promise(function (resolve, reject) {
    return (0, _easyRequire2.default)(function () {

      // TODO: Does not log :S
      log.pending('Processing webpack build');

      (0, _webpack2.default)(webpackConfig, function (fatalError, stats) {
        var jsonStats = stats && stats.toJson();

        // We can save jsonStats to be analyzed with
        // http://webpack.github.io/analyse or
        // https://github.com/robertknight/webpack-bundle-size-analyzer.
        // var fs = require('fs')
        // fs.writeFileSync('./bundle-stats.json', JSON.stringify(jsonStats))

        var warnings = jsonStats && jsonStats.warnings || [];

        warnings.forEach(function (warning) {
          log.pending('webpack warning: ' + warning);
        });

        var buildError = fatalError || jsonStats && jsonStats.errors[0];

        if (buildError) {
          reject('webpack error: ' + buildError);
          return;
        }

        var result = stats.toString({
          colors: true,
          version: false,
          hash: false,
          timings: false,
          chunks: false,
          chunkModules: false
        });

        log.success('Done with: ' + result);
        resolve();
      });
    });
  });
}

/**
 * Generate extension file inside release path
 *
 * @param  {String} path Release directory path
 * @return {Promise}
 */
function makeExtension(options) {
  return function () {
    return new Promise(function (resolve, reject) {
      // TODO detect system and Chrome path
      var chromeBinaryPath = '/Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome';
      console.log(_safe2.default.yellow('Building extension into \'' + options.release + '\''));

      setTimeout(function () {
        var commandParts = ['\'' + chromeBinaryPath + '\'', '--pack-extension=' + options.output];

        if (options.key) {
          commandParts.push('--pack-extension-key=' + options.key);
        }

        var command = '$(' + commandParts.join(" ") + ')';

        (0, _child_process.exec)(command, function (error, stdout, stderr) {
          if (stdout) {
            console.log(_safe2.default.yellow('stdout: ' + stdout));
          }

          if (stderr) {
            return reject('stderr: ' + stderr);
          }

          if (error !== null) {
            return reject('exec error: ' + stderr);
          }

          resolve('Extension builded in \'' + options.release + '\'');
        });
        // Long enought to prevent some unexpected errors
      }, 1000);
    });
  };
}

function build(options) {
  options = _extends({}, options, {
    key: options.key && _path2.default.resolve(options.key),
    release: options.output,
    output: _path2.default.join(options.output, 'source')
  });

  // TODO: check if release directory contain *.key file
  // If yes, then ask user if
  // 1) want to use it as key for build
  // 2) really really really want to override it
  prepareReleaseDir(options).then((0, _shared.prepareManifest)(options)).then(function (Manifest) {
    return (0, _webpackConfig2.default)(Manifest);
  }).then(webpackProduction).then(makeExtension(options))
  // Extension done
  .then(function (message) {
    console.log(_safe2.default.green(message));
  })
  // Some error happened
  .catch(function (error) {
    console.log(_safe2.default.red(error.stack || error));
  });
}

module.exports = build;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9idWlsZC5qcyJdLCJuYW1lcyI6WyJsb2ciLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJwcmVwYXJlUmVsZWFzZURpciIsIm9wdGlvbnMiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInJlbW92ZSIsInJlbGVhc2UiLCJta2RpcnMiLCJ3ZWJwYWNrUHJvZHVjdGlvbiIsIndlYnBhY2tDb25maWciLCJwZW5kaW5nIiwiZmF0YWxFcnJvciIsInN0YXRzIiwianNvblN0YXRzIiwidG9Kc29uIiwid2FybmluZ3MiLCJmb3JFYWNoIiwid2FybmluZyIsImJ1aWxkRXJyb3IiLCJlcnJvcnMiLCJyZXN1bHQiLCJ0b1N0cmluZyIsImNvbG9ycyIsInZlcnNpb24iLCJoYXNoIiwidGltaW5ncyIsImNodW5rcyIsImNodW5rTW9kdWxlcyIsInN1Y2Nlc3MiLCJtYWtlRXh0ZW5zaW9uIiwiY2hyb21lQmluYXJ5UGF0aCIsImNvbnNvbGUiLCJ5ZWxsb3ciLCJzZXRUaW1lb3V0IiwiY29tbWFuZFBhcnRzIiwib3V0cHV0Iiwia2V5IiwicHVzaCIsImNvbW1hbmQiLCJqb2luIiwiZXJyb3IiLCJzdGRvdXQiLCJzdGRlcnIiLCJidWlsZCIsInRoZW4iLCJNYW5pZmVzdCIsIm1lc3NhZ2UiLCJncmVlbiIsImNhdGNoIiwicmVkIiwic3RhY2siLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOzs7O0FBR0E7Ozs7QUFDQTs7QUFHQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFHQTs7OztBQUNBOzs7O0FBQ0E7O0lBQVlBLEc7O0FBQ1o7O0FBQ0E7Ozs7Ozs7O0FBaEJBQyxRQUFRQyxHQUFSLENBQVlDLFFBQVosR0FBdUIsWUFBdkI7O0FBRUE7OztBQUlBOzs7QUFLQTs7O0FBT0E7Ozs7OztBQU1BLFNBQVNDLGlCQUFULENBQTJCQyxPQUEzQixFQUFvQztBQUNsQyxTQUFPLElBQUlDLE9BQUosQ0FBWSxVQUFDQyxPQUFELEVBQVVDLE1BQVYsRUFB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T0FBTCxDQUFhRixRQUFRbUMsR0FBckIsQ0FGdEI7QUFHRTlCLGFBQVNMLFFBQVFrQyxNQUhuQjtBQUlFQSxZQUFRLGVBQUtJLElBQUwsQ0FBVXRDLFFBQVFrQyxNQUFsQixFQUEwQixRQUExQjtBQUpWOztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0FuQyxvQkFBa0JDLE9BQWxCLEVBQ0MyQyxJQURELENBQ00sNkJBQWdCM0MsT0FBaEIsQ0FETixFQUVDMkMsSUFGRCxDQUVNLFVBQUNDLFFBQUQsRUFBYztBQUNsQixXQUFPLDZCQUFpQkEsUUFBakIsQ0FBUDtBQUNELEdBSkQsRUFLQ0QsSUFMRCxDQUtNcEMsaUJBTE4sRUFNQ29DLElBTkQsQ0FNTWYsY0FBYzVCLE9BQWQsQ0FOTjtBQU9BO0FBUEEsR0FRQzJDLElBUkQsQ0FRTSxVQUFTRSxPQUFULEVBQWtCO0FBQ3RCZixZQUFRbkMsR0FBUixDQUFZLGVBQU1tRCxLQUFOLENBQVlELE9BQVosQ0FBWjtBQUNELEdBVkQ7QUFXQTtBQVhBLEdBWUNFLEtBWkQsQ0FZTyxVQUFTUixLQUFULEVBQWdCO0FBQ3JCVCxZQUFRbkMsR0FBUixDQUFZLGVBQU1xRCxHQUFOLENBQVVULE1BQU1VLEtBQU4sSUFBZVYsS0FBekIsQ0FBWjtBQUNELEdBZEQ7QUFlRDs7QUFFRFcsT0FBT0MsT0FBUCxHQUFpQlQsS0FBakIiLCJmaWxlIjoiYnVpbGQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJwcm9jZXNzLmVudi5OT0RFX0VOViA9ICdwcm9kdWN0aW9uJ1xuXG4vLyBOYXRpdmVcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHsgZXhlYyB9IGZyb20gJ2NoaWxkX3Byb2Nlc3MnXG5cbi8vIG5wbVxuaW1wb3J0IGZzIGZyb20gJ2ZzLWV4dHJhJ1xuaW1wb3J0IGNvbG9yIGZyb20gJ2NvbG9ycy9zYWZlJztcbmltcG9ydCB3ZWJwYWNrIGZyb20gJ3dlYnBhY2snXG5cbi8vIG91clxuaW1wb3J0IGVhc3lSZXF1aXJlIGZyb20gJy4vdXRpbHMvZWFzeVJlcXVpcmUnXG5pbXBvcnQgb3ZlcnJpZGVIb3RVcGRhdGVyIGZyb20gJy4vd2VicGFjay9vdmVycmlkZSdcbmltcG9ydCAqIGFzIGxvZyBmcm9tICcuL3V0aWxzL2xvZydcbmltcG9ydCB7IHByZXBhcmVNYW5pZmVzdCB9ICBmcm9tICcuL3NoYXJlZCdcbmltcG9ydCB3ZWJwYWNrR2VuZXJhdG9yIGZyb20gJy4vd2VicGFjay93ZWJwYWNrLmNvbmZpZy5wcm9kJ1xuXG4vKipcbiAqIENsZWFyIHJlZWxhc2UgZGlyZWN0b3J5XG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSBwYXRoIFJlbGVhc2UgZGlyZWN0b3J5IHBhdGhcbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKi9cbmZ1bmN0aW9uIHByZXBhcmVSZWxlYXNlRGlyKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBmcy5yZW1vdmUob3B0aW9ucy5yZWxlYXNlLCAoKSA9PiB7XG4gICAgICBmcy5ta2RpcnMob3B0aW9ucy5yZWxlYXNlLCAoKSA9PiB7XG4gICAgICAgIHJlc29sdmUoKVxuICAgICAgfSlcbiAgICB9KVxuICB9KVxufVxuXG4vKipcbiAqIEJ1aWxkIHByb2R1Y3Rpb24gcmVsZWFzZVxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gd2VicGFja0NvbmZpZ1xuICogQHJldHVybiB7UHJvbWlzZX1cbiAqL1xuZnVuY3Rpb24gd2VicGFja1Byb2R1Y3Rpb24od2VicGFja0NvbmZpZykge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHJldHVybiBlYXN5UmVxdWlyZSgoKSA9PiB7XG5cbiAgICAgIC8vIFRPRE86IERvZXMgbm90IGxvZyA6U1xuICAgICAgbG9nLnBlbmRpbmcoYFByb2Nlc3Npbmcgd2VicGFjayBidWlsZGApXG5cbiAgICAgIHdlYnBhY2sod2VicGFja0NvbmZpZywgZnVuY3Rpb24oZmF0YWxFcnJvciwgc3RhdHMpIHtcbiAgICAgICAgdmFyIGpzb25TdGF0cyA9IHN0YXRzICYmIHN0YXRzLnRvSnNvbigpXG5cbiAgICAgICAgLy8gV2UgY2FuIHNhdmUganNvblN0YXRzIHRvIGJlIGFuYWx5emVkIHdpdGhcbiAgICAgICAgLy8gaHR0cDovL3dlYnBhY2suZ2l0aHViLmlvL2FuYWx5c2Ugb3JcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3JvYmVydGtuaWdodC93ZWJwYWNrLWJ1bmRsZS1zaXplLWFuYWx5emVyLlxuICAgICAgICAvLyB2YXIgZnMgPSByZXF1aXJlKCdmcycpXG4gICAgICAgIC8vIGZzLndyaXRlRmlsZVN5bmMoJy4vYnVuZGxlLXN0YXRzLmpzb24nLCBKU09OLnN0cmluZ2lmeShqc29uU3RhdHMpKVxuXG4gICAgICAgIGNvbnN0IHdhcm5pbmdzID0gKGpzb25TdGF0cyAmJiBqc29uU3RhdHMud2FybmluZ3MpIHx8IFtdXG5cbiAgICAgICAgd2FybmluZ3MuZm9yRWFjaCgod2FybmluZykgPT4ge1xuICAgICAgICAgIGxvZy5wZW5kaW5nKGB3ZWJwYWNrIHdhcm5pbmc6ICR7d2FybmluZ31gKVxuICAgICAgICB9KVxuXG4gICAgICAgIGNvbnN0IGJ1aWxkRXJyb3IgPSBmYXRhbEVycm9yIHx8IChqc29uU3RhdHMgJiYganNvblN0YXRzLmVycm9yc1swXSlcblxuICAgICAgICBpZihidWlsZEVycm9yKSB7XG4gICAgICAgICAgcmVqZWN0KGB3ZWJwYWNrIGVycm9yOiAke2J1aWxkRXJyb3J9YClcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHN0YXRzLnRvU3RyaW5nKHtcbiAgICAgICAgICBjb2xvcnM6IHRydWUsXG4gICAgICAgICAgdmVyc2lvbjogZmFsc2UsXG4gICAgICAgICAgaGFzaDogZmFsc2UsXG4gICAgICAgICAgdGltaW5nczogZmFsc2UsXG4gICAgICAgICAgY2h1bmtzOiBmYWxzZSxcbiAgICAgICAgICBjaHVua01vZHVsZXM6IGZhbHNlXG4gICAgICAgIH0pXG5cbiAgICAgICAgbG9nLnN1Y2Nlc3MoYERvbmUgd2l0aDogJHtyZXN1bHR9YClcbiAgICAgICAgcmVzb2x2ZSgpXG4gICAgICB9KVxuICAgIH0pXG4gIH0pXG59XG5cbi8qKlxuICogR2VuZXJhdGUgZXh0ZW5zaW9uIGZpbGUgaW5zaWRlIHJlbGVhc2UgcGF0aFxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gcGF0aCBSZWxlYXNlIGRpcmVjdG9yeSBwYXRoXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICovXG5mdW5jdGlvbiBtYWtlRXh0ZW5zaW9uKG9wdGlvbnMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAvLyBUT0RPIGRldGVjdCBzeXN0ZW0gYW5kIENocm9tZSBwYXRoXG4gICAgICBjb25zdCBjaHJvbWVCaW5hcnlQYXRoID0gJy9BcHBsaWNhdGlvbnMvR29vZ2xlXFwgQ2hyb21lLmFwcC9Db250ZW50cy9NYWNPUy9Hb29nbGVcXCBDaHJvbWUnXG4gICAgICBjb25zb2xlLmxvZyhjb2xvci55ZWxsb3coYEJ1aWxkaW5nIGV4dGVuc2lvbiBpbnRvICcke29wdGlvbnMucmVsZWFzZX0nYCkpXG5cbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjb25zdCBjb21tYW5kUGFydHMgPSBbYCcke2Nocm9tZUJpbmFyeVBhdGh9J2AsIGAtLXBhY2stZXh0ZW5zaW9uPSR7b3B0aW9ucy5vdXRwdXR9YF1cblxuICAgICAgICBpZihvcHRpb25zLmtleSkge1xuICAgICAgICAgIGNvbW1hbmRQYXJ0cy5wdXNoKGAtLXBhY2stZXh0ZW5zaW9uLWtleT0ke29wdGlvbnMua2V5fWApXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjb21tYW5kID0gYFxcJCgke2NvbW1hbmRQYXJ0cy5qb2luKFwiIFwiKX0pYFxuXG4gICAgICAgIGV4ZWMoY29tbWFuZCwgKGVycm9yLCBzdGRvdXQsIHN0ZGVycikgPT4ge1xuICAgICAgICAgIGlmKHN0ZG91dCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coY29sb3IueWVsbG93KCdzdGRvdXQ6ICcgKyBzdGRvdXQpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZihzdGRlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3QoJ3N0ZGVycjogJyArIHN0ZGVycilcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZihlcnJvciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdCgnZXhlYyBlcnJvcjogJyArIHN0ZGVycilcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXNvbHZlKGBFeHRlbnNpb24gYnVpbGRlZCBpbiAnJHtvcHRpb25zLnJlbGVhc2V9J2ApXG4gICAgICAgIH0pXG4gICAgICAgIC8vIExvbmcgZW5vdWdodCB0byBwcmV2ZW50IHNvbWUgdW5leHBlY3RlZCBlcnJvcnNcbiAgICAgIH0sIDEwMDApXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBidWlsZChvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSB7XG4gICAgLi4ub3B0aW9ucyxcbiAgICBrZXk6IG9wdGlvbnMua2V5ICYmIHBhdGgucmVzb2x2ZShvcHRpb25zLmtleSksXG4gICAgcmVsZWFzZTogb3B0aW9ucy5vdXRwdXQsXG4gICAgb3V0cHV0OiBwYXRoLmpvaW4ob3B0aW9ucy5vdXRwdXQsICdzb3VyY2UnKVxuICB9XG5cbiAgLy8gVE9ETzogY2hlY2sgaWYgcmVsZWFzZSBkaXJlY3RvcnkgY29udGFpbiAqLmtleSBmaWxlXG4gIC8vIElmIHllcywgdGhlbiBhc2sgdXNlciBpZlxuICAvLyAxKSB3YW50IHRvIHVzZSBpdCBhcyBrZXkgZm9yIGJ1aWxkXG4gIC8vIDIpIHJlYWxseSByZWFsbHkgcmVhbGx5IHdhbnQgdG8gb3ZlcnJpZGUgaXRcbiAgcHJlcGFyZVJlbGVhc2VEaXIob3B0aW9ucylcbiAgLnRoZW4ocHJlcGFyZU1hbmlmZXN0KG9wdGlvbnMpKVxuICAudGhlbigoTWFuaWZlc3QpID0+IHtcbiAgICByZXR1cm4gd2VicGFja0dlbmVyYXRvcihNYW5pZmVzdClcbiAgfSlcbiAgLnRoZW4od2VicGFja1Byb2R1Y3Rpb24pXG4gIC50aGVuKG1ha2VFeHRlbnNpb24ob3B0aW9ucykpXG4gIC8vIEV4dGVuc2lvbiBkb25lXG4gIC50aGVuKGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICBjb25zb2xlLmxvZyhjb2xvci5ncmVlbihtZXNzYWdlKSlcbiAgfSlcbiAgLy8gU29tZSBlcnJvciBoYXBwZW5lZFxuICAuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHtcbiAgICBjb25zb2xlLmxvZyhjb2xvci5yZWQoZXJyb3Iuc3RhY2sgfHwgZXJyb3IpKVxuICB9KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJ1aWxkXG4iXX0=